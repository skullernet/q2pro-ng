/*
Copyright (C) 1997-2001 Id Software, Inc.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
*/

// client.h -- primary header for client

#pragma once

#include "shared/shared.h"
#include "shared/cgame.h"
#include "shared/refresh.h"
#include "bgame/bg_local.h"
#include "bgame/m_flash.h"
#include "cg_syscalls.h"

#ifndef Q2_VM
extern const cgame_import_t     *cgi;
#endif

//=============================================================================

typedef struct {
    entity_state_t      current;
    entity_state_t      prev;           // will always be valid, but might just be a copy of current

    vec3_t          mins, maxs;
    float           radius;             // from mid point

    unsigned        serverframe;        // if not current, this ent isn't in the frame

    int             trailcount;         // for diminishing grenade trails
    vec3_t          lerp_origin;        // for trails (variable hz)

    int             prev_frame;
    int             anim_start;

    int             step_time;
    float           step_factor;

    int             fly_stoptime;

    float           flashlightfrac;
} centity_t;

extern centity_t    cg_entities[MAX_EDICTS];

// view pitching times
#define DAMAGE_TIME 500
#define FALL_TIME   300
#define KICK_TIME   100
#define DUCK_TIME   100
#define STEP_TIME   100
#define QUAKE_TIME  1000
#define FLASH_TIME  400

#define MAX_STEP    32

//
// the cgame_state_t structure contains transient data from server. it
// is wiped completely at every time reset or demo seek.
//
typedef struct {
    vec3_t      predicted_origins[CMD_BACKUP];  // for debug comparing against server
    vec3_t      prediction_error;

    float       predicted_step;                // for stair up smoothing
    unsigned    predicted_step_time;
    unsigned    predicted_step_frame;

    player_state_t  predicted_ps;    // generated by CG_PredictMovement

    // rebuilt each valid frame
    centity_t       *solidEntities[MAX_PACKET_ENTITIES];
    int             numSolidEntities;

    cg_server_frame_t   *frame;     // received from server
    cg_server_frame_t   *oldframe;
    cg_server_frame_t   frames[2];
    unsigned        serverframe;

    int         time;           // this is the time value that the client
                                // is rendering at.  always <= cl.servertime
    float       lerpfrac;       // between oldframe and frame

    refdef_t    refdef;
    float       fov_x;      // interpolated
    float       fov_y;      // derived from fov_x assuming 4/3 aspect ratio
    int         lightlevel;

    vec3_t      v_forward, v_right, v_up;    // set when refdef.angles is set

    bool        thirdPersonView;
    float       thirdPersonAlpha;

    char        layout[MAX_NET_STRING];     // general 2D overlay
    int         inventory[MAX_ITEMS];

    // predicted values, used for smooth player entity movement in thirdperson view
    vec3_t      playerEntityOrigin;
    vec3_t      playerEntityAngles;

    // data for view weapon
    struct {
        struct {
            qhandle_t   model;
            int         time;
            float       roll, scale;
            vec3_t      offset;
        } muzzle;
        struct {
            vec3_t      origin;
            vec3_t      angles;
        } kick;
        int     prev_frame;
        int     anim_start;
    } weapon;

    float       xyspeed;
    float       bobfracsin;
    vec3_t      slow_view_angles;
    vec3_t      viewangles_delta;
    vec3_t      oldviewangles;

    vec3_t      kick_angles[2];
    vec3_t      kick_origin[2];
    int         kick_frame;

    int         fall_time;
    float       fall_value;

    int         v_dmg_time;
    float       v_dmg_pitch;
    float       v_dmg_roll;

    int         duck_time;
    float       duck_factor;

    float       bob_factor;

    int         quake_time;
    int         quake_frame;
    vec3_t      quake_angles[2];

    int         last_effects_time;
    qhandle_t   last_footstep;

    unsigned    hit_marker_time;
    int         hit_marker_count;
} cgame_state_t;

extern cgame_state_t    cg;

typedef enum {
    SS_DEATH1,
    SS_DEATH2,
    SS_DEATH3,
    SS_DEATH4,
    SS_FALL1,
    SS_FALL2,
    SS_GURP1,
    SS_GURP2,
    SS_DROWN,
    SS_JUMP,
    SS_PAIN25_1,
    SS_PAIN25_2,
    SS_PAIN50_1,
    SS_PAIN50_2,
    SS_PAIN75_1,
    SS_PAIN75_2,
    SS_PAIN100_1,
    SS_PAIN100_2,

    SS_MAX
} sexed_sound_t;

typedef struct {
    char        name[MAX_QPATH];
    qhandle_t   skin;
    qhandle_t   icon;
    char        model_name[MAX_QPATH];
    char        skin_name[MAX_QPATH];
    qhandle_t   model;
    qhandle_t   weaponmodel[MAX_CLIENTWEAPONS];
    qhandle_t   sounds[SS_MAX];
} clientinfo_t;

typedef struct {
    qhandle_t   ric1;
    qhandle_t   ric2;
    qhandle_t   ric3;
    qhandle_t   lashit;
    qhandle_t   spark5;
    qhandle_t   spark6;
    qhandle_t   spark7;
    qhandle_t   railg;
    qhandle_t   rockexp;
    qhandle_t   grenexp;
    qhandle_t   watrexp;
    qhandle_t   land1;
    qhandle_t   lightning;
    qhandle_t   disrexp;
    qhandle_t   hit_marker;
    qhandle_t   precache[MAX_SOUNDS];
} cg_sounds_t;

typedef enum {
    MFLASH_MACHN,
    MFLASH_SHOTG2,
    MFLASH_SHOTG,
    MFLASH_ROCKET,
    MFLASH_RAIL,
    MFLASH_LAUNCH,
    MFLASH_ETF_RIFLE,
    MFLASH_DIST,
    MFLASH_BOOMER,
    MFLASH_BLAST, // 0 = orange, 1 = blue, 2 = green
    MFLASH_BFG,
    MFLASH_BEAMER,

    MFLASH_TOTAL
} cg_muzzlefx_t;

typedef struct {
    qhandle_t   explode;
    qhandle_t   smoke;
    qhandle_t   flash;
    qhandle_t   parasite_segment;
    qhandle_t   grapple_cable;
    qhandle_t   explo4;
    qhandle_t   bfg_explo;
    qhandle_t   powerscreen;
    qhandle_t   lightning;
    qhandle_t   heatbeam;
    qhandle_t   shell;
    qhandle_t   muzzles[MFLASH_TOTAL];
    qhandle_t   precache[MAX_MODELS];
} cg_models_t;

typedef struct {
    qhandle_t   flare;
    qhandle_t   precache[MAX_IMAGES];
} cg_images_t;

#define MAX_MATERIALS       256
#define MAX_FOOTSTEP_SFX    15

typedef struct {
    int         num_sfx;
    qhandle_t   sfx[MAX_FOOTSTEP_SFX];
} cg_footstep_sfx_t;

typedef struct {
    int     length;
    float   map[MAX_QPATH - 1];
} cg_lightstyle_t;

//
// the cgame_static_t structure contains static information derived from server
// state. it is persistent through an arbitrary number of time resets and demo
// seeks, but wiped out at map change.
//
typedef struct {
    unsigned    realtime;
    float       frametime;

    int         maxclients;
    bool        demoplayback;

    char        statusbar[MAX_NET_STRING];

    clientinfo_t    clientinfo[MAX_CLIENTS];
    clientinfo_t    baseclientinfo;

    cg_sounds_t     sounds;
    cg_models_t     models;
    cg_images_t     images;

    cg_footstep_sfx_t   footsteps[MAX_MATERIALS];
    int                 num_footsteps;

    cg_lightstyle_t     lightstyles[MAX_LIGHTSTYLES];
} cgame_static_t;

extern cgame_static_t   cgs;

extern player_fog_t     cg_custom_fog;

//=============================================================================

#define NOPART_GRENADE_EXPLOSION    BIT(0)
#define NOPART_GRENADE_TRAIL        BIT(1)
#define NOPART_ROCKET_EXPLOSION     BIT(2)
#define NOPART_ROCKET_TRAIL         BIT(3)
#define NOPART_BLOOD                BIT(4)
#define NOPART_BLASTER_TRAIL        BIT(5)

#define NOEXP_GRENADE               BIT(0)
#define NOEXP_ROCKET                BIT(1)

#define DLHACK_ROCKET_COLOR         BIT(0)
#define DLHACK_SMALLER_EXPLOSION    BIT(1)
#define DLHACK_NO_MUZZLEFLASH       BIT(2)

//
// cvars
//
extern vm_cvar_t    cg_gun;
extern vm_cvar_t    cg_gunalpha;
extern vm_cvar_t    cg_gunfov;
extern vm_cvar_t    cg_gun_x;
extern vm_cvar_t    cg_gun_y;
extern vm_cvar_t    cg_gun_z;
extern vm_cvar_t    cg_run_pitch;
extern vm_cvar_t    cg_run_roll;
extern vm_cvar_t    cg_bob_up;
extern vm_cvar_t    cg_bob_pitch;
extern vm_cvar_t    cg_bob_roll;
extern vm_cvar_t    cg_skip_view_modifiers;
extern vm_cvar_t    cg_predict;
extern vm_cvar_t    cg_footsteps;
extern vm_cvar_t    cg_noskins;
extern vm_cvar_t    cg_rollhack;
extern vm_cvar_t    cg_noglow;
extern vm_cvar_t    cg_nobob;
extern vm_cvar_t    cg_nolerp;

#if USE_DEBUG
#define SHOWCLAMP(level, ...) \
    do { if (cg_showclamp.integer >= level) \
        Com_LPrintf(PRINT_DEVELOPER, __VA_ARGS__); } while (0)
#define SHOWMISS(...) \
    do { if (cg_showmiss.integer) \
        Com_LPrintf(PRINT_DEVELOPER, __VA_ARGS__); } while (0)
#define SHOWSTEP(...) \
    do { if (cg_showstep.integer) \
        Com_LPrintf(PRINT_DEVELOPER, __VA_ARGS__); } while (0)
extern vm_cvar_t    cg_showmiss;
extern vm_cvar_t    cg_showclamp;
extern vm_cvar_t    cg_showstep;
#else
#define SHOWMISS(...)
#define SHOWCLAMP(...)
#define SHOWSTEP(...)
#endif

extern vm_cvar_t    cg_vwep;

extern vm_cvar_t    cg_disable_particles;
extern vm_cvar_t    cg_disable_explosions;
extern vm_cvar_t    cg_dlight_hacks;
extern vm_cvar_t    cg_smooth_explosions;

extern vm_cvar_t    cg_chat_notify;
extern vm_cvar_t    cg_chat_sound;
extern vm_cvar_t    cg_chat_filter;

extern vm_cvar_t    cg_gibs;
extern vm_cvar_t    cg_flares;

extern vm_cvar_t    cg_thirdperson;
extern vm_cvar_t    cg_thirdperson_angle;
extern vm_cvar_t    cg_thirdperson_range;

extern vm_cvar_t    cg_adjustfov;
extern vm_cvar_t    cg_lerp_lightstyles;
extern vm_cvar_t    cg_muzzlelight_time;
extern vm_cvar_t    cg_muzzleflashes;
extern vm_cvar_t    cg_hit_markers;
extern vm_cvar_t    cg_railtrail_type;
extern vm_cvar_t    cg_railtrail_time;
extern vm_cvar_t    cg_railcore_color;
extern vm_cvar_t    cg_railcore_width;
extern vm_cvar_t    cg_railspiral_color;
extern vm_cvar_t    cg_railspiral_radius;

extern vm_cvar_t    cl_paused;
extern vm_cvar_t    sv_paused;
extern vm_cvar_t    com_timedemo;

extern vm_cvar_t    s_ambient;

//
// userinfo
//
extern vm_cvar_t    info_password;
extern vm_cvar_t    info_spectator;
extern vm_cvar_t    info_name;
extern vm_cvar_t    info_skin;
extern vm_cvar_t    info_rate;
extern vm_cvar_t    info_fov;
extern vm_cvar_t    info_msg;
extern vm_cvar_t    info_hand;
extern vm_cvar_t    info_gender;
extern vm_cvar_t    info_uf;

//=============================================================================

static inline void CG_AdvanceValue(float *restrict val, float target, float speed)
{
    if (*val < target) {
        *val += speed * cgs.frametime;
        if (*val > target)
            *val = target;
    } else if (*val > target) {
        *val -= speed * cgs.frametime;
        if (*val < target)
            *val = target;
    }
}

#define Com_SlowRand  Q_rand

//
// cg_main.c
//

void CG_Init(void);
void CG_Shutdown(void);
void CG_ClearState(void);

//
// cg_precache.c
//

void CG_RegisterMedia(void);
void CG_SetSky(void);
void CG_UpdateConfigstring(unsigned index);


//
// cg_entities.c
//

#define EF_TRAIL_MASK   (EF_ROCKET | EF_BLASTER | EF_HYPERBLASTER | EF_GIB | EF_GRENADE | \
                         EF_FLIES | EF_BFG | EF_TRAP | EF_FLAG1 | EF_FLAG2 | EF_TAGTRAIL | \
                         EF_TRACKERTRAIL | EF_TRACKER | EF_GREENGIB | EF_IONRIPPER | \
                         EF_BLUEHYPERBLASTER | EF_PLASMA)

#define IS_TRACKER(effects) \
    (((effects) & (EF_TRACKERTRAIL | EF_TRACKER)) == EF_TRACKERTRAIL)

void CG_DeltaFrame(void);
void CG_AddEntities(void);
float CG_LerpEntityAlpha(const centity_t *ent);
void CG_SetEntitySoundOrigin(const centity_t *ent);

//
// cg_view.c
//

void CG_RenderView(void);


//
// cg_events.c
//

typedef struct cg_sustain_s {
    int     id;
    int     type;
    int     endtime;
    int     nextthink;
    vec3_t  org;
    vec3_t  dir;
    int     color;
    int     count;
    int     magnitude;
    void    (*think)(struct cg_sustain_s *self);
} cg_sustain_t;

void CG_AddWeaponMuzzleFX(cg_muzzlefx_t fx, const vec3_t offset, float scale);
void CG_AddMuzzleFX(const vec3_t origin, const vec3_t angles, cg_muzzlefx_t fx, int skin, float scale);

void CG_SmokeAndFlash(const vec3_t origin);

void CG_EntityEffects(centity_t *cent);
void CG_EntityEvents(centity_t *cent);

void CG_RegisterTEntSounds(void);
void CG_RegisterTEntModels(void);
void CG_AddTEnts(void);
void CG_ClearTEnts(void);


//
// cg_predict.c
//

static inline bool CG_PredictionEnabled(void)
{
    return !cgs.demoplayback && cg_predict.integer && !(cg.frame->ps.pm_flags & PMF_NO_PREDICTION);
}

void CG_PredictAngles(void);
void CG_PredictMovement(void);
void CG_CheckPredictionError(void);
void CG_Trace(trace_t *tr, const vec3_t start, const vec3_t mins, const vec3_t maxs,
              const vec3_t end, unsigned passent, contents_t contentmask);
contents_t CG_PointContents(const vec3_t point);


//
// cg_effects.c
//
#define PARTICLE_GRAVITY    40
#define INSTANT_PARTICLE    -10000.0f

typedef struct cparticle_s {
    struct cparticle_s    *next;

    int     time;
    vec3_t  org;
    vec3_t  vel;
    vec3_t  accel;
    int     color;      // -1 => use rgba
    float   scale;
    float   alpha;
    float   alphavel;
    color_t rgba;
} cparticle_t;

typedef struct {
    int     key;        // so entities can reuse same entry
    vec3_t  color;
    vec3_t  origin;
    float   radius;
    int     die;        // stop lighting after this time
} cdlight_t;

typedef enum {
    DT_GIB,
    DT_GREENGIB,
    DT_ROCKET,
    DT_GRENADE,
    DT_FIREBALL,

    DT_COUNT
} diminishing_trail_t;

void CG_BigTeleportParticles(const vec3_t org);
void CG_DiminishingTrail(centity_t *ent, const vec3_t end, diminishing_trail_t type);
void CG_FlyEffect(centity_t *ent, const vec3_t origin);
void CG_BfgParticles(const entity_t *ent);
void CG_ItemRespawnParticles(const vec3_t org);
void CG_InitEffects(void);
void CG_ClearEffects(void);
void CG_BlasterParticles(const vec3_t org, const vec3_t dir);
void CG_ExplosionParticles(const vec3_t org);
void CG_BFGExplosionParticles(const vec3_t org);
void CG_BlasterTrail(centity_t *ent, const vec3_t end);
void CG_OldRailTrail(const vec3_t start, const vec3_t end);
void CG_BubbleTrail(const vec3_t start, const vec3_t end);
void CG_FlagTrail(centity_t *ent, const vec3_t end, int color);
void CG_MuzzleFlash(centity_t *ent, int weapon);
void CG_MuzzleFlash2(centity_t *ent, int weapon);
void CG_TeleporterParticles(const vec3_t org);
void CG_TeleportParticles(const vec3_t org);
void CG_ParticleEffect(const vec3_t org, const vec3_t dir, int color, int count);
void CG_ParticleEffect2(const vec3_t org, const vec3_t dir, int color, int count);
cparticle_t *CG_AllocParticle(void);
void CG_AddParticles(void);
cdlight_t *CG_AllocDlight(int key);
void CG_AddDLights(void);
void CG_SetLightStyle(int index, const char *s);
void CG_AddLightStyles(void);

void CG_BlasterParticles2(const vec3_t org, const vec3_t dir, unsigned int color);
void CG_BlasterTrail2(centity_t *ent, const vec3_t end);
void CG_DebugTrail(const vec3_t start, const vec3_t end);
void CG_Flashlight(int ent, const vec3_t pos);
void CG_ForceWall(const vec3_t start, const vec3_t end, int color);
void CG_BubbleTrail2(const vec3_t start, const vec3_t end, int dist);
void CG_Heatbeam(const vec3_t start, const vec3_t end);
void CG_ParticleSteamEffect(const vec3_t org, const vec3_t dir, int color, int count, int magnitude);
void CG_TrackerTrail(centity_t *ent, const vec3_t end);
void CG_TagTrail(centity_t *ent, const vec3_t end, int color);
void CG_ColorFlash(const vec3_t pos, int ent, int intensity, float r, float g, float b);
void CG_Tracker_Shell(const centity_t *cent, const vec3_t origin);
void CG_MonsterPlasma_Shell(const vec3_t origin);
void CG_ColorExplosionParticles(const vec3_t org, int color, int run);
void CG_ParticleSmokeEffect(const vec3_t org, const vec3_t dir, int color, int count, int magnitude);
void CG_Widowbeamout(cg_sustain_t *self);
void CG_Nukeblast(cg_sustain_t *self);
void CG_WidowSplash(const vec3_t pos);
void CG_IonripperTrail(centity_t *ent, const vec3_t end);
void CG_TrapParticles(centity_t *ent, const vec3_t origin);
void CG_ParticleEffect3(const vec3_t org, const vec3_t dir, int color, int count);
void CG_BerserkSlamParticles(const vec3_t org, const vec3_t dir);
void CG_PowerSplash(const centity_t *cent);
void CG_TeleporterParticles2(const vec3_t org);
void CG_HologramParticles(const vec3_t org);
void CG_BarrelExplodingParticles(const vec3_t org);


//
// cg_screen.c
//

extern vrect_t      scr_vrect;        // position of render window
extern vm_cvar_t    scr_viewsize;

void    SCR_Init(void);
void    SCR_Shutdown(void);
void    SCR_CenterPrint(const char *str, bool typewrite);
void    SCR_ClearCenterPrints(void);
void    SCR_RegisterMedia(void);
void    SCR_ModeChanged(void);
void    SCR_LagSample(const cg_server_frame_t *frame);
void    SCR_LagClear(void);
void    SCR_SetCrosshairColor(void);

float   SCR_FadeAlpha(unsigned startTime, unsigned visTime, unsigned fadeTime);
int     SCR_DrawStringEx(int x, int y, int flags, size_t maxlen, const char *s, qhandle_t font);
void    SCR_DrawStringMulti(int x, int y, int flags, size_t maxlen, const char *s, qhandle_t font);

void    SCR_ClearChatHUD_f(void);
void    SCR_AddToChatHUD(const char *text);

void    CG_ModeChanged(void);
void    CG_DrawFrame(unsigned msec, bool active, bool loading);

//
// cg_servercmds.c
//

void CG_ServerCommand(void);

//
// cg_consolecmds.c
//

void CG_RegisterCommands(void);
bool CG_ConsoleCommand(void);
void CG_CompleteCommand(int firstarg, int argnum);

//
// cg_frame.c
//
void CG_ProcessFrames(void);
