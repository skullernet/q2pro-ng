/*
Copyright (C) 1997-2001 Id Software, Inc.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
*/

// client.h -- primary header for client

#pragma once

#include "shared/shared.h"
#include "shared/bg_local.h"
#include "shared/cgame.h"
#include "shared/m_flash.h"
#include "shared/refresh.h"
#include "cg_syscalls.h"

#ifndef Q2_VM
extern const cgame_import_t     *cgi;
#endif

//=============================================================================

typedef struct {
    entity_state_t      current;
    entity_state_t      prev;           // will always be valid, but might just be a copy of current

    vec3_t          mins, maxs;
    float           radius;             // from mid point

    int             serverframe;        // if not current, this ent isn't in the frame

    int             trailcount;         // for diminishing grenade trails
    vec3_t          lerp_origin;        // for trails (variable hz)

    int             prev_frame;
    int             anim_start;

    //int           event_frame;

    int             fly_stoptime;

    float           flashlightfrac;
} centity_t;

extern centity_t    cg_entities[MAX_EDICTS];

#define MAX_CLIENTWEAPONMODELS        256       // PGM -- upped from 16 to fit the chainfist vwep

typedef enum {
    SS_DEATH1,
    SS_DEATH2,
    SS_DEATH3,
    SS_DEATH4,
    SS_FALL1,
    SS_FALL2,
    SS_GURP1,
    SS_GURP2,
    SS_DROWN,
    SS_JUMP,
    SS_PAIN25_1,
    SS_PAIN25_2,
    SS_PAIN50_1,
    SS_PAIN50_2,
    SS_PAIN75_1,
    SS_PAIN75_2,
    SS_PAIN100_1,
    SS_PAIN100_2,

    SS_MAX
} sexed_sound_t;

typedef struct {
    char name[MAX_QPATH];
    qhandle_t skin;
    qhandle_t icon;
    char model_name[MAX_QPATH];
    char skin_name[MAX_QPATH];
    qhandle_t model;
    qhandle_t weaponmodel[MAX_CLIENTWEAPONMODELS];
    qhandle_t sounds[SS_MAX];
} clientinfo_t;

// locally calculated frame flags for debug display
#define FF_SERVERDROP   BIT(4)
#define FF_BADFRAME     BIT(5)
#define FF_OLDFRAME     BIT(6)
#define FF_OLDENT       BIT(7)
#define FF_NODELTA      BIT(8)

#define DAMAGE_TIME 500
#define FALL_TIME   300
#define KICK_TIME   100
#define DUCK_TIME   100

//
// the client_state_t structure is wiped completely at every
// server map change
//
typedef struct {
    vec3_t      predicted_origins[CMD_BACKUP];  // for debug comparing against server
    vec3_t      prediction_error;

    float       predicted_step;                // for stair up smoothing
    unsigned    predicted_step_time;
    unsigned    predicted_step_frame;

    player_state_t  predicted_ps;    // generated by CG_PredictMovement

    // rebuilt each valid frame
    centity_t       *solidEntities[MAX_PACKET_ENTITIES];
    int             numSolidEntities;

    cg_server_frame_t   *frame;     // received from server
    cg_server_frame_t   *oldframe;
    cg_server_frame_t   frames[2];
    unsigned            processed_framenum, current_framenum;
    unsigned        servertime;
    int             serverdelta;

    int         time;           // this is the time value that the client
                                // is rendering at.  always <= cl.servertime
    float       lerpfrac;       // between oldframe and frame

    refdef_t    refdef;
    float       fov_x;      // interpolated
    float       fov_y;      // derived from fov_x assuming 4/3 aspect ratio
    int         lightlevel;

    vec3_t      v_forward, v_right, v_up;    // set when refdef.angles is set

    bool        thirdPersonView;
    float       thirdPersonAlpha;

    // predicted values, used for smooth player entity movement in thirdperson view
    vec3_t      playerEntityOrigin;
    vec3_t      playerEntityAngles;

    //
    // transient data from server
    //
    char        statusbar[MAX_NET_STRING];
    char        layout[MAX_NET_STRING];     // general 2D overlay
    int         inventory[MAX_ITEMS];

    //
    // server state information
    //
    int         serverstate;    // ss_* constants
    int         servercount;    // server identification for prespawns
    char        gamedir[MAX_QPATH];
    int         clientNum;            // never changed during gameplay, set by serverdata packet
    int         maxclients;

    char        mapname[MAX_QPATH]; // short format - q2dm1, etc

    //
    // locally derived information from server state
    //
    qhandle_t model_draw[MAX_MODELS];

    qhandle_t sound_precache[MAX_SOUNDS];
    qhandle_t image_precache[MAX_IMAGES];

    clientinfo_t    clientinfo[MAX_CLIENTS];
    clientinfo_t    baseclientinfo;

    char    weaponModels[MAX_CLIENTWEAPONMODELS][MAX_QPATH];
    int     numWeaponModels;

    // data for view weapon
    struct {
        struct {
            qhandle_t   model;
            int         time;
            float       roll, scale;
            vec3_t      offset;
        } muzzle;
        struct {
            vec3_t origin;
            vec3_t angles;
            int total, time;
        } kick;
    } weapon;

    float xyspeed;
    float bobfracsin;
    vec3_t slow_view_angles;
    vec3_t viewangles_delta;
    vec3_t oldviewangles;

    int fall_time;
    int fall_value;

    int damage_time;
    vec3_t damage_dir;
    float damage_kick;

    int duck_time;
    float duck_factor;

    unsigned hit_marker_time;
    int hit_marker_count;

    player_fog_t custom_fog;
} cgame_state_t;

extern cgame_state_t    cg;

/*
==================================================================

the client_static_t structure is persistent through an arbitrary number
of server connections

==================================================================
*/

typedef struct {
    bool demoplayback;
    float frametime;
    unsigned realtime;
} cgame_static_t;

extern cgame_static_t   cgs;

//=============================================================================

#define NOPART_GRENADE_EXPLOSION    BIT(0)
#define NOPART_GRENADE_TRAIL        BIT(1)
#define NOPART_ROCKET_EXPLOSION     BIT(2)
#define NOPART_ROCKET_TRAIL         BIT(3)
#define NOPART_BLOOD                BIT(4)
#define NOPART_BLASTER_TRAIL        BIT(5)

#define NOEXP_GRENADE               BIT(0)
#define NOEXP_ROCKET                BIT(1)

#define DLHACK_ROCKET_COLOR         BIT(0)
#define DLHACK_SMALLER_EXPLOSION    BIT(1)
#define DLHACK_NO_MUZZLEFLASH       BIT(2)

//
// cvars
//
extern vm_cvar_t    cg_gun;
extern vm_cvar_t    cg_gunalpha;
extern vm_cvar_t    cg_gunfov;
extern vm_cvar_t    cg_gun_x;
extern vm_cvar_t    cg_gun_y;
extern vm_cvar_t    cg_gun_z;
extern vm_cvar_t    cg_run_pitch;
extern vm_cvar_t    cg_run_roll;
extern vm_cvar_t    cg_bob_up;
extern vm_cvar_t    cg_bob_pitch;
extern vm_cvar_t    cg_bob_roll;
extern vm_cvar_t    cg_skip_view_modifiers;
extern vm_cvar_t    cg_predict;
extern vm_cvar_t    cg_footsteps;
extern vm_cvar_t    cg_noskins;
extern vm_cvar_t    cg_rollhack;
extern vm_cvar_t    cg_noglow;
extern vm_cvar_t    cg_nobob;
extern vm_cvar_t    cg_nolerp;

#if USE_DEBUG
#define SHOWCLAMP(level, ...) \
    do { if (cg_showclamp.integer >= level) \
        Com_LPrintf(PRINT_DEVELOPER, __VA_ARGS__); } while (0)
#define SHOWMISS(...) \
    do { if (cg_showmiss.integer) \
        Com_LPrintf(PRINT_DEVELOPER, __VA_ARGS__); } while (0)
#define SHOWSTEP(...) \
    do { if (cg_showstep.integer) \
        Com_LPrintf(PRINT_DEVELOPER, __VA_ARGS__); } while (0)
extern vm_cvar_t    cg_showmiss;
extern vm_cvar_t    cg_showclamp;
extern vm_cvar_t    cg_showstep;
#else
#define SHOWMISS(...)
#define SHOWCLAMP(...)
#define SHOWSTEP(...)
#endif

extern vm_cvar_t    cg_vwep;

extern vm_cvar_t    cg_disable_particles;
extern vm_cvar_t    cg_disable_explosions;
extern vm_cvar_t    cg_dlight_hacks;
extern vm_cvar_t    cg_smooth_explosions;

extern vm_cvar_t    cg_chat_notify;
extern vm_cvar_t    cg_chat_sound;
extern vm_cvar_t    cg_chat_filter;

extern vm_cvar_t    cg_gibs;
extern vm_cvar_t    cg_flares;

extern vm_cvar_t    cg_thirdperson;
extern vm_cvar_t    cg_thirdperson_angle;
extern vm_cvar_t    cg_thirdperson_range;

extern vm_cvar_t    cg_adjustfov;
extern vm_cvar_t    cg_lerp_lightstyles;
extern vm_cvar_t    cg_muzzlelight_time;
extern vm_cvar_t    cg_muzzleflashes;
extern vm_cvar_t    cg_hit_markers;
extern vm_cvar_t    cg_railtrail_type;
extern vm_cvar_t    cg_railtrail_time;
extern vm_cvar_t    cg_railcore_color;
extern vm_cvar_t    cg_railcore_width;
extern vm_cvar_t    cg_railspiral_color;
extern vm_cvar_t    cg_railspiral_radius;

extern vm_cvar_t    cl_paused;
extern vm_cvar_t    sv_paused;
extern vm_cvar_t    com_timedemo;

extern vm_cvar_t    s_ambient;

//
// userinfo
//
extern vm_cvar_t    info_password;
extern vm_cvar_t    info_spectator;
extern vm_cvar_t    info_name;
extern vm_cvar_t    info_skin;
extern vm_cvar_t    info_rate;
extern vm_cvar_t    info_fov;
extern vm_cvar_t    info_msg;
extern vm_cvar_t    info_hand;
extern vm_cvar_t    info_gender;
extern vm_cvar_t    info_uf;

//=============================================================================

static inline void CG_AdvanceValue(float *restrict val, float target, float speed)
{
    if (*val < target) {
        *val += speed * cgs.frametime;
        if (*val > target)
            *val = target;
    } else if (*val > target) {
        *val -= speed * cgs.frametime;
        if (*val < target)
            *val = target;
    }
}

#define Com_SlowRand  Q_rand

//
// main.c
//

int CG_CvarClampInteger(vm_cvar_t *var, int min, int max);
int CG_CvarClampValue(vm_cvar_t *var, float min, float max);

void CG_Init(void);
void CG_Shutdown(void);

//
// precache.c
//

bool CG_FileExists(const char *name);
void CG_RegisterSounds(void);
void CG_RegisterBspModels(void);
void CG_RegisterVWepModels(void);
void CG_SetSky(void);
void CG_PrepRefresh(void);
void CG_UpdateConfigstring(unsigned index);


//
// entities.c
//

#define EF_TRAIL_MASK   (EF_ROCKET | EF_BLASTER | EF_HYPERBLASTER | EF_GIB | EF_GRENADE | \
                         EF_FLIES | EF_BFG | EF_TRAP | EF_FLAG1 | EF_FLAG2 | EF_TAGTRAIL | \
                         EF_TRACKERTRAIL | EF_TRACKER | EF_GREENGIB | EF_IONRIPPER | \
                         EF_BLUEHYPERBLASTER | EF_PLASMA)

#define IS_TRACKER(effects) \
    (((effects) & (EF_TRACKERTRAIL | EF_TRACKER)) == EF_TRACKERTRAIL)

void CG_DeltaFrame(void);
void CG_AddEntities(void);
void CG_CalcViewValues(void);
void CG_SetEntitySoundOrigin(const centity_t *ent);

//
// view.c
//

void V_RenderView(void);


//
// tent.c
//

typedef struct cg_sustain_s {
    int     id;
    int     type;
    int     endtime;
    int     nextthink;
    vec3_t  org;
    vec3_t  dir;
    int     color;
    int     count;
    int     magnitude;
    void    (*think)(struct cg_sustain_s *self);
} cg_sustain_t;

typedef enum {
    MFLASH_MACHN,
    MFLASH_SHOTG2,
    MFLASH_SHOTG,
    MFLASH_ROCKET,
    MFLASH_RAIL,
    MFLASH_LAUNCH,
    MFLASH_ETF_RIFLE,
    MFLASH_DIST,
    MFLASH_BOOMER,
    MFLASH_BLAST, // 0 = orange, 1 = blue, 2 = green
    MFLASH_BFG,
    MFLASH_BEAMER,

    MFLASH_TOTAL
} cg_muzzlefx_t;

void CG_AddWeaponMuzzleFX(cg_muzzlefx_t fx, const vec3_t offset, float scale);
void CG_AddMuzzleFX(const vec3_t origin, const vec3_t angles, cg_muzzlefx_t fx, int skin, float scale);

void CG_SmokeAndFlash(const vec3_t origin);

void CG_EntityEvents(centity_t *cent);

void CG_RegisterTEntSounds(void);
void CG_RegisterTEntModels(void);
void CG_AddTEnts(void);
void CG_ClearTEnts(void);


//
// predict.c
//
void CG_PredictAngles(void);
void CG_PredictMovement(void);
void CG_CheckPredictionError(void);
void CG_Trace(trace_t *tr, const vec3_t start, const vec3_t mins, const vec3_t maxs,
              const vec3_t end, unsigned passent, contents_t contentmask);
contents_t CG_PointContents(const vec3_t point);


//
// effects.c
//
#define PARTICLE_GRAVITY    40
#define INSTANT_PARTICLE    -10000.0f

typedef struct cparticle_s {
    struct cparticle_s    *next;

    int     time;
    vec3_t  org;
    vec3_t  vel;
    vec3_t  accel;
    int     color;      // -1 => use rgba
    float   scale;
    float   alpha;
    float   alphavel;
    color_t rgba;
} cparticle_t;

typedef struct {
    int     key;        // so entities can reuse same entry
    vec3_t  color;
    vec3_t  origin;
    float   radius;
    int     die;        // stop lighting after this time
} cdlight_t;

typedef enum {
    DT_GIB,
    DT_GREENGIB,
    DT_ROCKET,
    DT_GRENADE,
    DT_FIREBALL,

    DT_COUNT
} diminishing_trail_t;

void CG_BigTeleportParticles(const vec3_t org);
void CG_DiminishingTrail(centity_t *ent, const vec3_t end, diminishing_trail_t type);
void CG_FlyEffect(centity_t *ent, const vec3_t origin);
void CG_BfgParticles(const entity_t *ent);
void CG_ItemRespawnParticles(const vec3_t org);
void CG_InitEffects(void);
void CG_ClearEffects(void);
void CG_BlasterParticles(const vec3_t org, const vec3_t dir);
void CG_ExplosionParticles(const vec3_t org);
void CG_BFGExplosionParticles(const vec3_t org);
void CG_BlasterTrail(centity_t *ent, const vec3_t end);
void CG_OldRailTrail(const vec3_t start, const vec3_t end);
void CG_BubbleTrail(const vec3_t start, const vec3_t end);
void CG_FlagTrail(centity_t *ent, const vec3_t end, int color);
void CG_MuzzleFlash(centity_t *ent, int weapon);
void CG_MuzzleFlash2(centity_t *ent, int weapon);
void CG_TeleporterParticles(const vec3_t org);
void CG_TeleportParticles(const vec3_t org);
void CG_ParticleEffect(const vec3_t org, const vec3_t dir, int color, int count);
void CG_ParticleEffect2(const vec3_t org, const vec3_t dir, int color, int count);
cparticle_t *CG_AllocParticle(void);
void CG_AddParticles(void);
cdlight_t *CG_AllocDlight(int key);
void CG_AddDLights(void);
void CG_SetLightStyle(int index, const char *s);
void CG_AddLightStyles(void);

//
// newfx.c
//

void CG_BlasterParticles2(const vec3_t org, const vec3_t dir, unsigned int color);
void CG_BlasterTrail2(centity_t *ent, const vec3_t end);
void CG_DebugTrail(const vec3_t start, const vec3_t end);
void CG_Flashlight(int ent, const vec3_t pos);
void CG_ForceWall(const vec3_t start, const vec3_t end, int color);
void CG_BubbleTrail2(const vec3_t start, const vec3_t end, int dist);
void CG_Heatbeam(const vec3_t start, const vec3_t end);
void CG_ParticleSteamEffect(const vec3_t org, const vec3_t dir, int color, int count, int magnitude);
void CG_TrackerTrail(centity_t *ent, const vec3_t end);
void CG_TagTrail(centity_t *ent, const vec3_t end, int color);
void CG_ColorFlash(const vec3_t pos, int ent, int intensity, float r, float g, float b);
void CG_Tracker_Shell(const centity_t *cent, const vec3_t origin);
void CG_MonsterPlasma_Shell(const vec3_t origin);
void CG_ColorExplosionParticles(const vec3_t org, int color, int run);
void CG_ParticleSmokeEffect(const vec3_t org, const vec3_t dir, int color, int count, int magnitude);
void CG_Widowbeamout(cg_sustain_t *self);
void CG_Nukeblast(cg_sustain_t *self);
void CG_WidowSplash(const vec3_t pos);
void CG_IonripperTrail(centity_t *ent, const vec3_t end);
void CG_TrapParticles(centity_t *ent, const vec3_t origin);
void CG_ParticleEffect3(const vec3_t org, const vec3_t dir, int color, int count);
void CG_BerserkSlamParticles(const vec3_t org, const vec3_t dir);
void CG_PowerSplash(const centity_t *cent);
void CG_TeleporterParticles2(const vec3_t org);
void CG_HologramParticles(const vec3_t org);
void CG_BarrelExplodingParticles(const vec3_t org);


//
// screen.c
//
extern vrect_t      scr_vrect;        // position of render window

void    SCR_Init(void);
void    SCR_Shutdown(void);
void    SCR_CenterPrint(const char *str, bool typewrite);
void    SCR_ClearCenterPrints(void);
void    SCR_RegisterMedia(void);
void    SCR_ModeChanged(void);
void    SCR_LagSample(const cg_server_frame_t *frame);
void    SCR_LagClear(void);
void    SCR_SetCrosshairColor(void);

float   SCR_FadeAlpha(unsigned startTime, unsigned visTime, unsigned fadeTime);
int     SCR_DrawStringEx(int x, int y, int flags, size_t maxlen, const char *s, qhandle_t font);
void    SCR_DrawStringMulti(int x, int y, int flags, size_t maxlen, const char *s, qhandle_t font);

void    SCR_ClearChatHUD_f(void);
void    SCR_AddToChatHUD(const char *text);

void    CG_ModeChanged(void);
void    CG_DrawActiveFrame(unsigned msec);

//
// servercmd.c
//

void CG_ServerCommand(void);
bool CG_ConsoleCommand(void);

//
// frame.c
//
void CG_ProcessFrames(void);
